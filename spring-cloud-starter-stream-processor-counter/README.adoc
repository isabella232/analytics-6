//tag::ref-doc[]
= Counter Processor

Pass-Through Processor that computes multiple Counters from the messages that pass through. The input messages are re-send unchanged!
Using the Micrometer library the Counter Processor integrates with the popular TSDB for persisting and processing the counter values.

By default the Counter Processor increments the `message`.`name` counter on every received message. The `message-counter-enabled` controls the behavior of the message counter.

If tag expressions are provided (via the `counter.tag.expression.<tagKey>=<tagValue SpEL expression> property) then the `name` counter is incremented. Every SpEL expression may evaluate into multiple values causing multiple counter increments for the same message (one fore every value resolved).

If `fixed tags` are provided they are include in all message and expression counters.

== Options

//tag::configuration-properties[]
$$counter.message-counter-enabled$$:: $$Enables counting the number of messages processed. Uses the 'message.' counter name prefix to distinct it form the expression based counter. The message counter includes the fixed tags when provided.$$ *($$Boolean$$, default: `$$true$$`)*
$$counter.name$$:: $$The name of the counter to increment.$$ *($$String$$, default: `$$<none>$$`)*
$$counter.name-expression$$:: $$A SpEL expression (against the incoming Message) to derive the name of the counter to increment.$$ *($$Expression$$, default: `$$<none>$$`)*
$$counter.tag.expression$$:: $$Computes tags from SpEL expression. Single SpEL expression can produce an array of values, which in turn means distinct name/value tags. Every name/value tag will produce a separate counter increment. Tag expression format is: counter.tag.expression.[tag-name]=[SpEL expression]$$ *($$Map<String, Expression>$$, default: `$$<none>$$`)*
$$counter.tag.fixed$$:: $$Custom tags assigned to every counter increment measurements. This is a map so the property convention fixed tags is: counter.tag.fixed.[tag-name]=[tag-value]$$ *($$Map<String, String>$$, default: `$$<none>$$`)*
//end::configuration-properties[]

//end::ref-doc[]

== Build

Build involves two-stages. First build the apps and generate the binder specific app starters projects:
```
$ ./mvnw clean install -PgenerateApps
```

You can find the corresponding binder based projects in the `apps` subfolder. You can then cd into the apps folder:

```
$ cd apps
```
and build all binder projects
```
$ ./mvnw clean package
```

== Examples

```
java -jar counter-processor.jar ... use the properties TODO
```

And here is a example pipeline that uses counter:

```
counter-stream= TODO
```
